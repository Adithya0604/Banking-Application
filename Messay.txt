Always use _id(users) or userID(usersAccounts) for user Existences and auth.

Always use the _id(usersTransactions) for user Transaction. 

// async function userRegisterMiddleWareEmail(request, response, next) {
//   const { Email } = request.body;

//   try {
//     const list = ["gmail", "hotmail", "yahoo", "email"];
//     const Server = "Please enter your email first.";

//     const pattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

//     if (!Email || !pattern.test(Email)) {
//       return response.status(ErrorCodes.Bad_Request).json({
//         success: false,
//         EnterFirst: Server,
//       });
//     }

//     next();
//   } catch (error) {
//     return next(error);
//   }
// }


--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
the schema options you‚Äôll actually use (80/20)
const AccountSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true, index: true },

  accountNumber: { type: String, required: true, unique: true, trim: true },

  accountType: { 
    type: String, 
    enum: ['Savings', 'Current', 'Salary'], 
    required: true 
  },

  balance: { type: Number, required: true, default: 0, min: 0 },

  nickname: { type: String, trim: true, minlength: 1, maxlength: 40 },

  // good for emails/usernames:
  email: { type: String, lowercase: true, trim: true, match: /.+@.+\..+/ }
}, { timestamps: true, versionKey: false });

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
what each does (short + useful)
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------

-->.  @    required: true ‚Äì must be present (mongoose validator).

-->.  @    unique: true ‚Äì creates a unique index in MongoDB (not a validator). build indexes!

-->.  @    enum: [...] ‚Äì limits values to the listed set.

-->.  @    default: ... ‚Äì value used when missing.

-->.  @    min / max ‚Äì numeric bounds; minlength / maxlength for strings.

-->.  @    match: /regex/ ‚Äì string must match regex.

-->.  @    trim: true ‚Äì auto-trims whitespace.

-->.  @    lowercase / uppercase: true ‚Äì auto-case transform on set.

-->.  @    select: false ‚Äì field is hidden by default in queries (e.g., password).

-->.  @    index: true ‚Äì adds a non-unique index (good for frequent filters like userId).

-->.  @    timestamps: true ‚Äì auto adds createdAt, updatedAt.

-->.  @    ref: 'ModelName' ‚Äì enables population (foreign-key-like).

-->.  @    immutable: true ‚Äì field can‚Äôt change after creation (e.g., accountNumber).


--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
good-to-know but niche:
sparse: true or partial indexes ‚Äì use with unique if the field is optional; otherwise multiple docs with missing values can collide on the unique index.
toJSON/toObject: { virtuals: true } ‚Äì include virtual fields (like id) when serializing.
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------


--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
the ‚Äúweird‚Äù bits you‚Äôll actually hit
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------


unique isn‚Äôt validation. it‚Äôs an index. if the index isn‚Äôt built yet, dupes can slip in during startup. ensure indexes are created (Model.syncIndexes() in setup or let mongoose auto-build in dev).

optional + unique fields: without sparse/partial index, multiple null/missing values will conflict. add a sparse/partial unique index if the field is not always present.

ObjectId equality: === won‚Äôt work between ObjectId and string. use .equals() or cast both to strings.

.lean() strips document methods/virtuals: no doc.id, no doc.save(). you get plain JSON. faster, but know what you lose.

dates/timezones: new Date('2025-09-02') parses as UTC; in IST you may see off-by-one when formatting. store UTC, format on output.

async/await: always await mongoose ops; wrap in try/catch. un-awaited calls = ghost bugs.

casting: mongoose will cast strings to ObjectId if valid. invalid strings throw cast errors ‚Üí validate first with isValidObjectId.


--------------------------------------------------------------------________-----------------------
the core idea (id vs _id)
--------------------------------------------------------------------________-----------------------

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
_id (mongodb)
every document has one. default type is ObjectId (a 12-byte value). it‚Äôs the primary key in the database.

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
id (mongoose convenience)
mongoose adds a virtual getter: doc.id ‚Üí string version of doc._id. it does not exist in the db; it‚Äôs just String(doc._id) for your convenience.

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
in requests like req.user.id
that value comes from your auth middleware/JWT payload. many apps store the user id as a string in the token (sub/id). that‚Äôs why you see req.user.id. it‚Äôs fine‚Äîmongoose will cast that string to ObjectId when you query.

quick mental model

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
DB level: use _id (ObjectId).

App level (code/tokens/json): often use id (string).

they point to the same identifier; one is binary-ish (ObjectId), the other is human-friendly (string).

when you‚Äôll see each

on mongoose documents: you‚Äôll see both doc._id (ObjectId) and doc.id (string virtual).

on plain objects (.lean() or raw JSON): you‚Äôll usually only see _id unless you configure virtuals in toJSON/toObject.

in JWT / req.user: typically id (string), because you put it there.
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------


--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
1. Why the problem happened
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------

In our project, the transaction initially failed because the relatedTranactionId field in the schema expected a Mongo ObjectId, but we were assigning a UUID string. After fixing it to use txn._id or new mongoose.Types.ObjectId(), the issue was resolved.

Additionally, MongoDB transactions require a replica set. On a standalone MongoDB server, multi-document transactions are not supported. That‚Äôs why we initiated a local replica set (rs.initiate()) for the transfer functionality to work.

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
2. What is a MongoDB Replica Set?
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------

A replica set is a group of MongoDB servers that maintain the same data.

Primary node ‚Üí handles writes (and reads by default)

Secondary nodes ‚Üí replicate the data from the primary

Automatic failover ‚Üí if primary fails, one secondary becomes primary

Benefits of a replica set:

High availability ‚Äì ensures the database is available even if one server fails

Data redundancy ‚Äì prevents data loss

Supports transactions ‚Äì multi-document ACID transactions require a replica set

Even in our local project, we use a replica set to enable transactions. In production, all banking and critical systems use replica sets.

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
3. What is a Transaction in MongoDB?
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------

A transaction allows multiple operations to execute atomically:

All operations succeed, or all fail

Guarantees consistency even if something goes wrong

Example: Money transfer

Deduct money from sender

Add money to receiver

Create transaction record

If any step fails, MongoDB rolls back all changes.

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
4. Can you do transactions without a replica set?
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------

Standalone MongoDB supports only single-document atomic operations

Multi-document transactions require a replica set

Single-document operations are still safe but cannot ensure atomicity across multiple documents

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
5. Are transactions only for money?
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------

No. Transactions are useful whenever multiple related updates must all succeed together.

Examples:

Banking: money transfers between accounts

E-commerce: deduct stock, create order, charge payment

Inventory: update multiple warehouses

Social apps: update multiple documents on one user action

Rule of thumb: use transactions whenever partial updates could cause errors or inconsistencies.

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
6. Summary Table
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
Concept	Purpose	Required?
Replica set	Enable transactions, high availability, data replication	Yes for multi-document transactions
Transaction	Ensure all-or-nothing updates across multiple documents	Only if multi-document atomicity is needed
Single-node Mongo	Supports single-document atomic updates, but no multi-document transactions	For simple use cases
RelatedTranactionId	Reference to a transaction document	Schema type must match (ObjectId)

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
üí° Key Insight:
In real-world banking apps, transactions + replica sets are standard practice because they ensure atomicity, durability, and fault tolerance.