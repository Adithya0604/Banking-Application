Always use _id(users) or userID(usersAccounts) for user Existences and auth.

Always use the _id(usersTransactions) for user Transaction. 

// async function userRegisterMiddleWareEmail(request, response, next) {
//   const { Email } = request.body;

//   try {
//     const list = ["gmail", "hotmail", "yahoo", "email"];
//     const Server = "Please enter your email first.";

//     const pattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

//     if (!Email || !pattern.test(Email)) {
//       return response.status(ErrorCodes.Bad_Request).json({
//         success: false,
//         EnterFirst: Server,
//       });
//     }

//     next();
//   } catch (error) {
//     return next(error);
//   }
// }


--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
the schema options you’ll actually use (80/20)
const AccountSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true, index: true },

  accountNumber: { type: String, required: true, unique: true, trim: true },

  accountType: { 
    type: String, 
    enum: ['Savings', 'Current', 'Salary'], 
    required: true 
  },

  balance: { type: Number, required: true, default: 0, min: 0 },

  nickname: { type: String, trim: true, minlength: 1, maxlength: 40 },

  // good for emails/usernames:
  email: { type: String, lowercase: true, trim: true, match: /.+@.+\..+/ }
}, { timestamps: true, versionKey: false });

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
what each does (short + useful)
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------

-->.  @    required: true – must be present (mongoose validator).

-->.  @    unique: true – creates a unique index in MongoDB (not a validator). build indexes!

-->.  @    enum: [...] – limits values to the listed set.

-->.  @    default: ... – value used when missing.

-->.  @    min / max – numeric bounds; minlength / maxlength for strings.

-->.  @    match: /regex/ – string must match regex.

-->.  @    trim: true – auto-trims whitespace.

-->.  @    lowercase / uppercase: true – auto-case transform on set.

-->.  @    select: false – field is hidden by default in queries (e.g., password).

-->.  @    index: true – adds a non-unique index (good for frequent filters like userId).

-->.  @    timestamps: true – auto adds createdAt, updatedAt.

-->.  @    ref: 'ModelName' – enables population (foreign-key-like).

-->.  @    immutable: true – field can’t change after creation (e.g., accountNumber).


--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
good-to-know but niche:
sparse: true or partial indexes – use with unique if the field is optional; otherwise multiple docs with missing values can collide on the unique index.
toJSON/toObject: { virtuals: true } – include virtual fields (like id) when serializing.
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------


--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
the “weird” bits you’ll actually hit
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------


unique isn’t validation. it’s an index. if the index isn’t built yet, dupes can slip in during startup. ensure indexes are created (Model.syncIndexes() in setup or let mongoose auto-build in dev).

optional + unique fields: without sparse/partial index, multiple null/missing values will conflict. add a sparse/partial unique index if the field is not always present.

ObjectId equality: === won’t work between ObjectId and string. use .equals() or cast both to strings.

.lean() strips document methods/virtuals: no doc.id, no doc.save(). you get plain JSON. faster, but know what you lose.

dates/timezones: new Date('2025-09-02') parses as UTC; in IST you may see off-by-one when formatting. store UTC, format on output.

async/await: always await mongoose ops; wrap in try/catch. un-awaited calls = ghost bugs.

casting: mongoose will cast strings to ObjectId if valid. invalid strings throw cast errors → validate first with isValidObjectId.


--------------------------------------------------------------------________-----------------------
the core idea (id vs _id)
--------------------------------------------------------------------________-----------------------

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
_id (mongodb)
every document has one. default type is ObjectId (a 12-byte value). it’s the primary key in the database.

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
id (mongoose convenience)
mongoose adds a virtual getter: doc.id → string version of doc._id. it does not exist in the db; it’s just String(doc._id) for your convenience.

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
in requests like req.user.id
that value comes from your auth middleware/JWT payload. many apps store the user id as a string in the token (sub/id). that’s why you see req.user.id. it’s fine—mongoose will cast that string to ObjectId when you query.

quick mental model

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
DB level: use _id (ObjectId).

App level (code/tokens/json): often use id (string).

they point to the same identifier; one is binary-ish (ObjectId), the other is human-friendly (string).

when you’ll see each

on mongoose documents: you’ll see both doc._id (ObjectId) and doc.id (string virtual).

on plain objects (.lean() or raw JSON): you’ll usually only see _id unless you configure virtuals in toJSON/toObject.

in JWT / req.user: typically id (string), because you put it there.
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------


--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
1. Why the problem happened
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------

In our project, the transaction initially failed because the relatedTranactionId field in the schema expected a Mongo ObjectId, but we were assigning a UUID string. After fixing it to use txn._id or new mongoose.Types.ObjectId(), the issue was resolved.

Additionally, MongoDB transactions require a replica set. On a standalone MongoDB server, multi-document transactions are not supported. That’s why we initiated a local replica set (rs.initiate()) for the transfer functionality to work.

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
2. What is a MongoDB Replica Set?
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------

A replica set is a group of MongoDB servers that maintain the same data.

Primary node → handles writes (and reads by default)

Secondary nodes → replicate the data from the primary

Automatic failover → if primary fails, one secondary becomes primary

Benefits of a replica set:

High availability – ensures the database is available even if one server fails

Data redundancy – prevents data loss

Supports transactions – multi-document ACID transactions require a replica set

Even in our local project, we use a replica set to enable transactions. In production, all banking and critical systems use replica sets.

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
3. What is a Transaction in MongoDB?
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------

A transaction allows multiple operations to execute atomically:

All operations succeed, or all fail

Guarantees consistency even if something goes wrong

Example: Money transfer

Deduct money from sender

Add money to receiver

Create transaction record

If any step fails, MongoDB rolls back all changes.

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
4. Can you do transactions without a replica set?
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------

Standalone MongoDB supports only single-document atomic operations

Multi-document transactions require a replica set

Single-document operations are still safe but cannot ensure atomicity across multiple documents

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
5. Are transactions only for money?
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------

No. Transactions are useful whenever multiple related updates must all succeed together.

Examples:

Banking: money transfers between accounts

E-commerce: deduct stock, create order, charge payment

Inventory: update multiple warehouses

Social apps: update multiple documents on one user action

Rule of thumb: use transactions whenever partial updates could cause errors or inconsistencies.

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
6. Summary Table
--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
Concept	Purpose	Required?
Replica set	Enable transactions, high availability, data replication	Yes for multi-document transactions
Transaction	Ensure all-or-nothing updates across multiple documents	Only if multi-document atomicity is needed
Single-node Mongo	Supports single-document atomic updates, but no multi-document transactions	For simple use cases
RelatedTranactionId	Reference to a transaction document	Schema type must match (ObjectId)

--------------------------------------------------------------------________-----------------------
--------------------------------------------------------------------________-----------------------
💡 Key Insight:
In real-world banking apps, transactions + replica sets are standard practice because they ensure atomicity, durability, and fault tolerance.